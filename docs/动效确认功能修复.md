# 动效确认功能修复

## 问题描述

在实现动效确认功能后，发现点击确认后的第二次点击并没有执行删除/清空操作，而是像第一次点击一样（或者没反应）。

## 原因分析

问题出在 `handleClickOutside` 事件监听器上：
1. 我们在全局添加了 `mousedown` 监听器，用于点击外部时取消确认状态。
2. 当用户点击删除按钮进行确认（第二次点击）时，`mousedown` 事件先于 `onClick` 事件触发。
3. 原来的逻辑是：只要有点击，就直接执行 `setDeletingSessionId(null)`。
4. 结果：在 `onClick` 执行之前，状态已经被重置为 null。
5. 当 `onClick` 执行时，`deletingSessionId` 已经是 null，所以 `deletingSessionId === session.id` 为 false。
6. 函数判断 `confirmed` 为 false，再次进入确认状态（实际上是重新开始）。

## 解决方案

**核心思路：**
在 `handleClickOutside` 中，检查点击的目标元素是否是"删除按钮"本身。如果是，就不执行取消操作；如果不是（即点击了外部），才执行取消操作。

### 1. 添加标识类名

为相关的按钮添加特定的类名：
- 删除Session按钮：`voyaru-delete-session-btn`
- 清空历史按钮：`voyaru-clear-history-btn`

### 2. 修改事件监听逻辑

使用 `event.target.closest('.classname')` 来判断点击是否发生在指定按钮内部。

```typescript
useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
        const target = event.target as HTMLElement;
        
        // ... 其他逻辑
        
        // 检查是否点击了删除Session按钮
        if (!target.closest('.voyaru-delete-session-btn')) {
            setDeletingSessionId(null);
        }
        
        // 检查是否点击了清空历史按钮
        if (!target.closest('.voyaru-clear-history-btn')) {
            setClearHistoryConfirm(false);
        }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
        document.removeEventListener('mousedown', handleClickOutside);
    };
}, [editingMessageId]);
```

## 验证流程

1. **第一次点击删除按钮**
   - `mousedown` 触发 -> `closest` 检测到是按钮 -> 不执行取消 -> 状态保持 null
   - `onClick` 触发 -> `confirmed` 为 false -> `setDeletingSessionId(id)`
   - 结果：进入确认状态 ✅

2. **第二次点击删除按钮**
   - `mousedown` 触发 -> `closest` 检测到是按钮 -> 不执行取消 -> 状态保持 id
   - `onClick` 触发 -> `confirmed` 为 true -> 执行删除逻辑
   - 结果：删除成功 ✅

3. **点击外部**
   - `mousedown` 触发 -> `closest` 检测不是按钮 -> 执行 `setDeletingSessionId(null)`
   - 结果：取消确认状态 ✅

## 完成状态

✅ 修复点击确认失效的问题  
✅ 保持点击外部取消的功能  
✅ 代码逻辑更加严谨  
✅ 通过构建测试  

